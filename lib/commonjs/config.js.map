{"version":3,"sources":["config.js"],"names":["InvalidArgument","require","validatorHandlers","mapOfValidators","processorHandlers","mapOfProcessors","config","addValidatorToMap","tokens","tag","handler","forEach","op","addProcessorToMap","isUnary","unary","overrideProcessor","overrideValidator","getValidatorTag","getValidator","getProcessorTagAndType","getProcessor","loadMessages","messages","module","exports"],"mappings":";;AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAsBC,OAAO,CAAC,aAAD,CAAnC;;AAEA,MAAMC,iBAAiB,GAAG,EAA1B;AACA,MAAMC,eAAe,GAAG,EAAxB;AAEA,MAAMC,iBAAiB,GAAG,EAA1B;AACA,MAAMC,eAAe,GAAG,EAAxB,C,CAEA;;AACA,MAAMC,MAAM,GAAG;AACXC,EAAAA,iBAAiB,EAAE,CAACC,MAAD,EAASC,GAAT,EAAcC,OAAd,KAA0B;AACzCF,IAAAA,MAAM,CAACG,OAAP,CAAgBC,EAAD,IAAQ;AACnB,UAAIA,EAAE,IAAIT,eAAV,EAA2B;AACvB,cAAM,IAAIH,eAAJ,CACD,iCAAgCY,EAAG,EADlC,EAEF;AACIA,UAAAA,EADJ;AAEIH,UAAAA;AAFJ,SAFE,CAAN;AAOH;;AACDN,MAAAA,eAAe,CAACS,EAAD,CAAf,GAAsBH,GAAtB;AACH,KAXD;;AAaA,QAAIA,GAAG,IAAIP,iBAAX,EAA8B;AAC1B,YAAM,IAAIF,eAAJ,CACD,qCAAoCS,GAAI,EADvC,CAAN;AAGH;;AAEDP,IAAAA,iBAAiB,CAACO,GAAD,CAAjB,GAAyBC,OAAzB;AACH,GAtBU;AAuBXG,EAAAA,iBAAiB,EAAE,CAACL,MAAD,EAASC,GAAT,EAAcK,OAAd,EAAuBJ,OAAvB,KAAmC;AAClD,QAAI,OAAOI,OAAP,KAAmB,UAAnB,IAAiCJ,OAAO,IAAI,IAAhD,EAAsD;AAClDA,MAAAA,OAAO,GAAGI,OAAV;AACAA,MAAAA,OAAO,GAAG,KAAV;AACH;;AAEDN,IAAAA,MAAM,CAACG,OAAP,CAAgBC,EAAD,IAAQ;AACnB,UAAIA,EAAE,IAAIP,eAAV,EAA2B;AACvB,cAAM,IAAIL,eAAJ,CACD,iCAAgCY,EAAG,EADlC,EAEF;AACIA,UAAAA,EADJ;AAEIH,UAAAA,GAFJ;AAGIM,UAAAA,KAAK,EAAED;AAHX,SAFE,CAAN;AAQH;;AACDT,MAAAA,eAAe,CAACO,EAAD,CAAf,GAAsB,CAACH,GAAD,EAAMK,OAAN,CAAtB;AACH,KAZD;;AAcA,QAAIL,GAAG,IAAIL,iBAAX,EAA8B;AAC1B,YAAM,IAAIJ,eAAJ,CACD,qCAAoCS,GAAI,EADvC,CAAN;AAGH;;AAEDL,IAAAA,iBAAiB,CAACK,GAAD,CAAjB,GAAyBC,OAAzB;AACH,GAlDU;AAmDXM,EAAAA,iBAAiB,EAAE,CAACP,GAAD,EAAMC,OAAN,KAAkB;AACjCN,IAAAA,iBAAiB,CAACK,GAAD,CAAjB,GAAyBC,OAAzB;AACH,GArDU;AAsDXO,EAAAA,iBAAiB,EAAE,CAACR,GAAD,EAAMC,OAAN,KAAkB;AACjCR,IAAAA,iBAAiB,CAACO,GAAD,CAAjB,GAAyBC,OAAzB;AACH,GAxDU;AA0DXQ,EAAAA,eAAe,EAAGN,EAAD,IAAQT,eAAe,CAACS,EAAD,CA1D7B;AA2DXO,EAAAA,YAAY,EAAGV,GAAD,IAASP,iBAAiB,CAACO,GAAD,CA3D7B;AA6DXW,EAAAA,sBAAsB,EAAGR,EAAD,IAAQP,eAAe,CAACO,EAAD,CA7DpC;AA8DXS,EAAAA,YAAY,EAAGZ,GAAD,IAASL,iBAAiB,CAACK,GAAD,CA9D7B;AA+DXa,EAAAA,YAAY,EAAGC,QAAD,IAAejB,MAAM,CAACiB,QAAP,GAAkBA;AA/DpC,CAAf;AAkEAC,MAAM,CAACC,OAAP,GAAiBnB,MAAjB","sourcesContent":["const { InvalidArgument } = require('@genx/error');\n\nconst validatorHandlers = {};\nconst mapOfValidators = {};\n\nconst processorHandlers = {};\nconst mapOfProcessors = {};\n\n//JSON Expression Syntax Runtime Configuration\nconst config = {\n    addValidatorToMap: (tokens, tag, handler) => {\n        tokens.forEach((op) => {\n            if (op in mapOfValidators) {\n                throw new InvalidArgument(\n                    `Duplicate validator operator: ${op}`,\n                    {\n                        op,\n                        tag,\n                    }\n                );\n            }\n            mapOfValidators[op] = tag;\n        });\n\n        if (tag in validatorHandlers) {\n            throw new InvalidArgument(\n                `Duplicate handler for validation: ${tag}`\n            );\n        }\n\n        validatorHandlers[tag] = handler;\n    },\n    addProcessorToMap: (tokens, tag, isUnary, handler) => {\n        if (typeof isUnary === 'function' && handler == null) {\n            handler = isUnary;\n            isUnary = false;\n        }\n\n        tokens.forEach((op) => {\n            if (op in mapOfProcessors) {\n                throw new InvalidArgument(\n                    `Duplicate processor operator: ${op}`,\n                    {\n                        op,\n                        tag,\n                        unary: isUnary,\n                    }\n                );\n            }\n            mapOfProcessors[op] = [tag, isUnary];\n        });\n\n        if (tag in processorHandlers) {\n            throw new InvalidArgument(\n                `Duplicate handler for processing: ${tag}`\n            );\n        }\n\n        processorHandlers[tag] = handler;\n    },\n    overrideProcessor: (tag, handler) => {\n        processorHandlers[tag] = handler;\n    },\n    overrideValidator: (tag, handler) => {\n        validatorHandlers[tag] = handler;\n    },\n\n    getValidatorTag: (op) => mapOfValidators[op],\n    getValidator: (tag) => validatorHandlers[tag],\n\n    getProcessorTagAndType: (op) => mapOfProcessors[op],\n    getProcessor: (tag) => processorHandlers[tag],\n    loadMessages: (messages) => (config.messages = messages),\n};\n\nmodule.exports = config;\n"]}