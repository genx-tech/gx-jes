{"version":3,"sources":["../../src/transform.js"],"names":["MSG","config","messages","PFX_MAP","PFX_REDUCE","applyBinaryOperator","value","op","opValue","context","handler","getTransformer","Error","INVALID_TRANSFORMER_HANDLER","applyUnaryOperator","tag","applyOperator","currentValue","rightValue","isUnary","dev","RIGHT_OPERAND_NOT_EMPTY","transformCollection","collectionOp","opMeta","expectedFieldValue","Array","isArray","_map","_mapValues","item","key","length","INVALID_COLLECTION_OP_EXPR","ops","REDUCE","result","INVALID_COLLECTION_OP","transform","expr","replaceLeft","path","$$ROOT","$$PARENT","$$CURRENT","$$KEY","map","undefined","reduce","exprItem","typeExpr","SYNTAX_NUMBER_AS_EXPR","startsWith","pos","indexOf","substr","getTransformerTagAndType","INVALID_TRANSFORMER_OP","REQUIRE_RIGHT_OPERAND","SYNTAX_INVALID_EXPR","hasOperator","fieldName","l","SYNTAX_OP_NOT_ALONE","substring","complexKey","actualFieldValue","childFieldValue"],"mappings":"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","sourcesContent":["// JSON Expression Syntax (JES)\nimport _isEmpty from 'lodash/isEmpty';\nimport _reduce from 'lodash/reduce';\nimport _map from 'lodash/map';\nimport _mapValues from 'lodash/mapValues';\n\nimport { get as _get, set as _set } from '@genx/july';\n\nimport config, { getChildContext } from './config';\nimport ops from './transformerOperators';\n\nconst MSG = config.messages;\n\nconst PFX_MAP = '|>'; // map\nconst PFX_REDUCE = '|+'; // reduce 1. intermediate = result op [key, value] 2. result = result op intermediate\n\n/**\n * Apply a bianry operator to a value\n * @param {*} value\n * @param {*} op\n * @param {*} opValue\n * @param {*} context\n * @returns {*}\n */\nfunction applyBinaryOperator(value, op, opValue, context) {\n    const handler = config.getTransformer(op);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(op));\n    }\n\n    return handler(value, opValue, context);\n}\n\n/**\n * Apply an unary operator to a value\n * @param {*} value\n * @param {*} tag\n * @param {*} context\n * @returns {*}\n */\nfunction applyUnaryOperator(value, tag, context) {\n    const handler = config.getTransformer(tag);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(tag));\n    }\n\n    return handler(value, context);\n}\n\n/**\n * Apply an operator to a value with operator meta\n * @param {*} currentValue\n * @param {*} rightValue\n * @param {*} opMeta\n * @param {*} context\n * @returns\n */\nfunction applyOperator(currentValue, rightValue, [op, isUnary], context) {\n    if (isUnary) {\n        if (config.dev && !_isEmpty(rightValue)) {\n            throw new Error(MSG.RIGHT_OPERAND_NOT_EMPTY(op));\n        }\n        return applyUnaryOperator(currentValue, op, context);\n    }\n\n    return applyBinaryOperator(currentValue, op, rightValue, context);\n}\n\n/**\n * Apply an collection iteration operator with operator meta\n * @param {*} currentValue\n * @param {*} collectionOp\n * @param {*} opMeta\n * @param {*} expectedFieldValue\n * @param {*} context\n * @returns\n */\nfunction transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context) {\n    const isUnary = opMeta[1];\n\n    switch (collectionOp) {\n        case PFX_MAP:\n            return (Array.isArray(currentValue) ? _map : _mapValues)(currentValue, (item, key) =>\n                applyOperator(item, expectedFieldValue, opMeta, getChildContext(context, currentValue, key, item))\n            );\n\n        case PFX_REDUCE:\n            if (\n                !Array.isArray(expectedFieldValue) ||\n                (isUnary && expectedFieldValue.length !== 1) ||\n                (!isUnary && expectedFieldValue.length !== 2)\n            ) {\n                throw new Error(MSG.INVALID_COLLECTION_OP_EXPR(ops.REDUCE, opMeta[0], expectedFieldValue));\n            }\n\n            return _reduce(\n                currentValue,\n                (result, item, key) =>\n                    applyOperator(\n                        result,\n                        expectedFieldValue[1],\n                        opMeta,\n                        getChildContext(context, currentValue, key, item)\n                    ),\n                expectedFieldValue[0]\n            );\n\n        default:\n            throw new Error(MSG.INVALID_COLLECTION_OP(collectionOp));\n    }\n}\n\n/**\n * If $ operator used, only one a time is allowed\n * e.g.\n * {\n *    $groupBy: 'key'\n * }\n *\n *\n * @param {*} currentValue\n * @param {*} expr\n * @param {*} context\n * @param {boolean} replaceLeft - Whether the expression will replace the left value chain,like a setOp\n */\nfunction transform(currentValue, expr, context, replaceLeft) {\n    if (expr == null) {\n        return replaceLeft ? expr : currentValue;\n    }\n\n    if (context == null) {\n        context = {\n            path: null,\n            $$ROOT: currentValue,\n            $$PARENT: null,\n            $$CURRENT: currentValue,\n            $$KEY: null,\n        };\n    }\n\n    if (Array.isArray(expr)) {\n        if (replaceLeft) {\n            return expr.map((item) => transform(undefined, item, { ...context }, true));\n        }\n\n        return expr.reduce((result, exprItem) => transform(result, exprItem, { ...context }), currentValue);\n    }\n\n    const typeExpr = typeof expr;\n\n    if (typeExpr === 'boolean') {\n        if (replaceLeft) {\n            return expr;\n        }\n\n        return expr ? currentValue : undefined;\n    }\n\n    if (typeExpr === 'number' || typeExpr === 'bigint') {\n        if (replaceLeft) {\n            return expr;\n        }\n\n        throw new Error(MSG.SYNTAX_NUMBER_AS_EXPR);\n    }\n\n    if (typeExpr === 'string') {\n        if (expr.startsWith('$$')) {\n            //get from context\n            const pos = expr.indexOf('.');\n            if (pos === -1) {\n                return context[expr];\n            }\n\n            return _get(context[expr.substr(0, pos)], expr.substr(pos + 1));\n        }\n\n        if (replaceLeft) {\n            return expr;\n        }\n\n        const opMeta = config.getTransformerTagAndType(expr);\n        if (!opMeta) {\n            throw new Error(MSG.INVALID_TRANSFORMER_OP(expr));\n        }\n\n        if (!opMeta[1]) {\n            throw new Error(MSG.REQUIRE_RIGHT_OPERAND(expr));\n        }\n\n        return applyUnaryOperator(currentValue, opMeta[0], context);\n    }\n\n    if (typeExpr !== 'object') {\n        throw new Error(MSG.SYNTAX_INVALID_EXPR(expr));\n    }\n\n    if (replaceLeft) {\n        return _mapValues(expr, (item) => transform(undefined, item, context, true));\n    }\n\n    let result,\n        hasOperator = false;\n\n    for (let fieldName in expr) {\n        let expectedFieldValue = expr[fieldName];\n\n        const l = fieldName.length;\n\n        if (l > 1) {\n            if (fieldName[0] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = applyOperator(currentValue, expectedFieldValue, opMeta, context);\n                hasOperator = true;\n                continue;\n            }\n\n            if (l > 3 && fieldName[0] === '|' && fieldName[2] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const collectionOp = fieldName.substring(0, 2);\n                fieldName = fieldName.substring(2);\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context);\n                hasOperator = true;\n                continue;\n            }\n        }\n\n        if (hasOperator) {\n            throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n        }\n\n        let complexKey = fieldName.indexOf('.') !== -1;\n\n        //pick a field and then apply manipulation\n        let actualFieldValue =\n            currentValue != null ? (complexKey ? _get(currentValue, fieldName) : currentValue[fieldName]) : undefined;\n\n        const childFieldValue = transform(\n            actualFieldValue,\n            expectedFieldValue,\n            getChildContext(context, currentValue, fieldName, actualFieldValue)\n        );\n\n        if (typeof childFieldValue !== 'undefined') {\n            result == null && (result = {});\n            if (complexKey) {\n                _set(result, fieldName, childFieldValue);\n            } else {\n                result[fieldName] = childFieldValue;\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default transform;\n"],"file":"transform.js"}