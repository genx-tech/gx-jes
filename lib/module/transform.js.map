{"version":3,"sources":["transform.js"],"names":["_isEmpty","_reduce","_map","_mapValues","get","_get","set","_set","config","getChildContext","ops","MSG","messages","PFX_MAP","PFX_REDUCE","applyBinaryOperator","value","op","opValue","context","handler","getTransformer","Error","INVALID_TRANSFORMER_HANDLER","applyUnaryOperator","tag","applyOperator","currentValue","rightValue","isUnary","dev","RIGHT_OPERAND_NOT_EMPTY","transformCollection","collectionOp","opMeta","expectedFieldValue","Array","isArray","item","key","length","INVALID_COLLECTION_OP_EXPR","REDUCE","result","INVALID_COLLECTION_OP","transform","expr","replaceLeft","path","$$ROOT","$$PARENT","$$CURRENT","$$KEY","map","undefined","reduce","exprItem","typeExpr","SYNTAX_NUMBER_AS_EXPR","startsWith","pos","indexOf","substr","getTransformerTagAndType","INVALID_TRANSFORMER_OP","REQUIRE_RIGHT_OPERAND","SYNTAX_INVALID_EXPR","hasOperator","fieldName","l","SYNTAX_OP_NOT_ALONE","substring","complexKey","actualFieldValue","childFieldValue"],"mappings":"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","sourcesContent":["// JSON Expression Syntax (JES)\nimport _isEmpty from 'lodash/isEmpty';\nimport _reduce from 'lodash/reduce';\nimport _map from 'lodash/map';\nimport _mapValues from 'lodash/mapValues';\n\nimport { get as _get, set as _set } from '@genx/july';\n\nimport config, { getChildContext } from './config';\nimport ops from './transformerOperators';\n\nconst MSG = config.messages;\n\nconst PFX_MAP = '|>'; // map\nconst PFX_REDUCE = '|+'; // reduce 1. intermediate = result op [key, value] 2. result = result op intermediate\n\n/**\n * Apply a bianry operator to a value\n * @param {*} value\n * @param {*} op\n * @param {*} opValue\n * @param {*} context\n * @returns {*}\n */\nfunction applyBinaryOperator(value, op, opValue, context) {\n    const handler = config.getTransformer(op);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(op));\n    }\n\n    return handler(value, opValue, context);\n}\n\n/**\n * Apply an unary operator to a value\n * @param {*} value\n * @param {*} tag\n * @param {*} context\n * @returns {*}\n */\nfunction applyUnaryOperator(value, tag, context) {\n    const handler = config.getTransformer(tag);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(tag));\n    }\n\n    return handler(value, context);\n}\n\n/**\n * Apply an operator to a value with operator meta\n * @param {*} currentValue\n * @param {*} rightValue\n * @param {*} opMeta\n * @param {*} context\n * @returns\n */\nfunction applyOperator(currentValue, rightValue, [op, isUnary], context) {\n    if (isUnary) {\n        if (config.dev && !_isEmpty(rightValue)) {\n            throw new Error(MSG.RIGHT_OPERAND_NOT_EMPTY(op));\n        }\n        return applyUnaryOperator(currentValue, op, context);\n    }\n\n    return applyBinaryOperator(currentValue, op, rightValue, context);\n}\n\n/**\n * Apply an collection iteration operator with operator meta\n * @param {*} currentValue\n * @param {*} collectionOp\n * @param {*} opMeta\n * @param {*} expectedFieldValue\n * @param {*} context\n * @returns\n */\nfunction transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context) {\n    const isUnary = opMeta[1];\n\n    switch (collectionOp) {\n        case PFX_MAP:\n            return (Array.isArray(currentValue) ? _map : _mapValues)(currentValue, (item, key) =>\n                applyOperator(item, expectedFieldValue, opMeta, getChildContext(context, currentValue, key, item))\n            );\n\n        case PFX_REDUCE:\n            if (\n                !Array.isArray(expectedFieldValue) ||\n                (isUnary && expectedFieldValue.length !== 1) ||\n                (!isUnary && expectedFieldValue.length !== 2)\n            ) {\n                throw new Error(MSG.INVALID_COLLECTION_OP_EXPR(ops.REDUCE, opMeta[0], expectedFieldValue));\n            }\n\n            return _reduce(\n                currentValue,\n                (result, item, key) =>\n                    applyOperator(\n                        result,\n                        expectedFieldValue[1],\n                        opMeta,\n                        getChildContext(context, currentValue, key, item)\n                    ),\n                expectedFieldValue[0]\n            );\n\n        default:\n            throw new Error(MSG.INVALID_COLLECTION_OP(collectionOp));\n    }\n}\n\n/**\n * If $ operator used, only one a time is allowed\n * e.g.\n * {\n *    $groupBy: 'key'\n * }\n *\n *\n * @param {*} currentValue\n * @param {*} expr\n * @param {*} context\n * @param {boolean} replaceLeft - Whether the expression will replace the left value chain,like a setOp\n */\nfunction transform(currentValue, expr, context, replaceLeft) {\n    if (expr == null) {\n        return replaceLeft ? expr : currentValue;\n    }\n\n    if (context == null) {\n        context = {\n            path: null,\n            $$ROOT: currentValue,\n            $$PARENT: null,\n            $$CURRENT: currentValue,\n            $$KEY: null,\n        };\n    }\n\n    if (Array.isArray(expr)) {\n        if (replaceLeft) {\n            return expr.map((item) => transform(undefined, item, { ...context }, true));\n        }\n\n        return expr.reduce((result, exprItem) => transform(result, exprItem, { ...context }), currentValue);\n    }\n\n    const typeExpr = typeof expr;\n\n    if (typeExpr === 'boolean') {\n        if (replaceLeft) {\n            return expr;\n        }\n\n        return expr ? currentValue : undefined;\n    }\n\n    if (typeExpr === 'number' || typeExpr === 'bigint') {\n        if (replaceLeft) {\n            return expr;\n        }\n\n        throw new Error(MSG.SYNTAX_NUMBER_AS_EXPR);\n    }\n\n    if (typeExpr === 'string') {\n        if (expr.startsWith('$$')) {\n            //get from context\n            const pos = expr.indexOf('.');\n            if (pos === -1) {\n                return context[expr];\n            }\n\n            return _get(context[expr.substr(0, pos)], expr.substr(pos + 1));\n        }\n\n        if (replaceLeft) {\n            return expr;\n        }\n\n        const opMeta = config.getTransformerTagAndType(expr);\n        if (!opMeta) {\n            throw new Error(MSG.INVALID_TRANSFORMER_OP(expr));\n        }\n\n        if (!opMeta[1]) {\n            throw new Error(MSG.REQUIRE_RIGHT_OPERAND(expr));\n        }\n\n        return applyUnaryOperator(currentValue, opMeta[0], context);\n    }\n\n    if (typeExpr !== 'object') {\n        throw new Error(MSG.SYNTAX_INVALID_EXPR(expr));\n    }\n\n    if (replaceLeft) {\n        return _mapValues(expr, (item) => transform(undefined, item, context, true));\n    }\n\n    let result,\n        hasOperator = false;\n\n    for (let fieldName in expr) {\n        let expectedFieldValue = expr[fieldName];\n\n        const l = fieldName.length;\n\n        if (l > 1) {\n            if (fieldName[0] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = applyOperator(currentValue, expectedFieldValue, opMeta, context);\n                hasOperator = true;\n                continue;\n            }\n\n            if (l > 3 && fieldName[0] === '|' && fieldName[2] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const collectionOp = fieldName.substring(0, 2);\n                fieldName = fieldName.substring(2);\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context);\n                hasOperator = true;\n                continue;\n            }\n        }\n\n        if (hasOperator) {\n            throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n        }\n\n        let complexKey = fieldName.indexOf('.') !== -1;\n\n        //pick a field and then apply manipulation\n        let actualFieldValue =\n            currentValue != null ? (complexKey ? _get(currentValue, fieldName) : currentValue[fieldName]) : undefined;\n\n        const childFieldValue = transform(\n            actualFieldValue,\n            expectedFieldValue,\n            getChildContext(context, currentValue, fieldName, actualFieldValue)\n        );\n\n        if (typeof childFieldValue !== 'undefined') {\n            result == null && (result = {});\n            if (complexKey) {\n                _set(result, fieldName, childFieldValue);\n            } else {\n                result[fieldName] = childFieldValue;\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default transform;\n"]}