{"version":3,"sources":["validate.js"],"names":["ValidationError","config","getChildContext","ops","isPlainObject","get","_get","MSG","messages","getUnmatchedExplanation","op","leftValue","rightValue","context","$$ERROR","validationErrors","Error","getter","name","invalidType","value","type","options","reason","TYPE","throwError","path","plainError","test","left","right","handler","getValidator","INVALID_TEST_HANLDER","validate","actual","expectedJES","abortEarly","length","SYNTAX_INVALID_EXPR","asPredicate","errors","_options","operator","_context","opValue","getValidatorTag","UNSUPPORTED_VALIDATION_OP","fieldName","complexKey","indexOf","undefined","MATCH","EQUAL","push"],"mappings":"AAAA;AACA,OAAOA,eAAP,MAA4B,mBAA5B;AACA,OAAOC,MAAP,IAAiBC,eAAjB,QAAwC,UAAxC;AACA,OAAOC,GAAP,MAAgB,qBAAhB;AACA,SAASC,aAAT,EAAwBC,GAAG,IAAIC,IAA/B,QAA2C,YAA3C;AAEA,MAAMC,GAAG,GAAGN,MAAM,CAACO,QAAnB;;AAEA,SAASC,uBAAT,CAAiCC,EAAjC,EAAqCC,SAArC,EAAgDC,UAAhD,EAA4DC,OAA5D,EAAqE;AACjE,MAAIA,OAAO,CAACC,OAAZ,EAAqB;AACjB,WAAOD,OAAO,CAACC,OAAf;AACH;;AAED,MAAI,CAACP,GAAG,CAACQ,gBAAT,EAA2B;AACvB,UAAM,IAAIC,KAAJ,CAAU,qDAAV,CAAN;AACH;;AACD,QAAMC,MAAM,GAAGV,GAAG,CAACQ,gBAAJ,CAAqBL,EAArB,CAAf;AACA,SAAOO,MAAM,CAACJ,OAAO,CAACK,IAAT,EAAeP,SAAf,EAA0BC,UAA1B,EAAsCC,OAAtC,CAAb;AACH;;AAED,OAAO,SAASM,WAAT,CAAqBC,KAArB,EAA4BC,IAA5B,EAAkCC,OAAlC,EAA2CT,OAA3C,EAAoD;AACvD,QAAMU,MAAM,GAAGhB,GAAG,CAACQ,gBAAJ,CAAqBZ,GAAG,CAACqB,IAAzB,EAA+BX,OAAO,CAACK,IAAvC,EAA6CE,KAA7C,EAAoDC,IAApD,EAA0DR,OAA1D,CAAf;;AAEA,MAAIS,OAAO,CAACG,UAAZ,EAAwB;AACpB,UAAM,IAAIzB,eAAJ,CAAoBuB,MAApB,EAA4BH,KAA5B,EAAmCP,OAAO,CAACa,IAA3C,CAAN;AACH;;AAED,SAAOJ,OAAO,CAACK,UAAR,GAAqBJ,MAArB,GAA8B,IAAIvB,eAAJ,CAAoBuB,MAApB,EAA4BH,KAA5B,EAAmCP,OAAO,CAACa,IAA3C,CAArC;AACH;AAED,OAAO,SAASE,IAAT,CAAcC,IAAd,EAAoBnB,EAApB,EAAwBoB,KAAxB,EAA+BR,OAA/B,EAAwCT,OAAxC,EAAiD;AACpD,QAAMkB,OAAO,GAAG9B,MAAM,CAAC+B,YAAP,CAAoBtB,EAApB,CAAhB;;AAEA,MAAI,CAACqB,OAAL,EAAc;AACV,UAAM,IAAIf,KAAJ,CAAUT,GAAG,CAAC0B,oBAAJ,CAAyBvB,EAAzB,CAAV,CAAN;AACH;;AAED,SAAOqB,OAAO,CAACF,IAAD,EAAOC,KAAP,EAAcR,OAAd,EAAuBT,OAAvB,CAAd;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASqB,QAAT,CAAkBC,MAAlB,EAA0BC,WAA1B,EAAuG;AAAA,MAAhEd,OAAgE,uEAAtD;AAAEG,IAAAA,UAAU,EAAE,IAAd;AAAoBY,IAAAA,UAAU,EAAE;AAAhC,GAAsD;AAAA,MAAdxB,OAAc,uEAAJ,EAAI;AACnG,QAAMQ,IAAI,GAAG,OAAOe,WAApB;;AAEA,MAAIf,IAAI,KAAK,QAAb,EAAuB;AACnB,QAAIe,WAAW,CAACE,MAAZ,KAAuB,CAAvB,IAA4BF,WAAW,CAAC,CAAD,CAAX,KAAmB,GAAnD,EAAwD;AACpD,YAAM,IAAIpB,KAAJ,CAAUT,GAAG,CAACgC,mBAAJ,CAAwBH,WAAxB,CAAV,CAAN;AACH;;AAED,WAAOF,QAAQ,CAACC,MAAD,EAAS;AAAE,OAACC,WAAD,GAAe;AAAjB,KAAT,EAAkCd,OAAlC,EAA2CT,OAA3C,CAAf;AACH;;AAED,QAAM;AAAEY,IAAAA,UAAF;AAAcY,IAAAA,UAAd;AAA0BG,IAAAA,WAA1B;AAAuCb,IAAAA;AAAvC,MAAsDL,OAA5D;;AAEA,MAAIc,WAAW,IAAI,IAAnB,EAAyB;AACrB,WAAO,IAAP;AACH;;AAED,MAAI;AAAEV,IAAAA;AAAF,MAAWb,OAAf;AACA,QAAM4B,MAAM,GAAG,EAAf;;AACA,QAAMC,QAAQ,GAAG,CAACL,UAAD,IAAeZ,UAAf,GAA4B,EAAE,GAAGH,OAAL;AAAcG,IAAAA,UAAU,EAAE;AAA1B,GAA5B,GAAgEH,OAAjF;;AAEA,OAAK,IAAIqB,QAAT,IAAqBP,WAArB,EAAkC;AAC9B,QAAI1B,EAAJ,EAAQmB,IAAR,EAAce,QAAd;;AAEA,UAAMC,OAAO,GAAGT,WAAW,CAACO,QAAD,CAA3B;;AAEA,SACI;AACCA,IAAAA,QAAQ,CAACL,MAAT,GAAkB,CAAlB,IAAuBK,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAAxC,IACA;AACCA,IAAAA,QAAQ,CAACL,MAAT,GAAkB,CAAlB,IAAuBK,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAAvC,IAA8CA,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAJnE,EAKE;AACE;AACAjC,MAAAA,EAAE,GAAGT,MAAM,CAAC6C,eAAP,CAAuBH,QAAvB,CAAL;;AACA,UAAI,CAACjC,EAAL,EAAS;AACL,cAAM,IAAIM,KAAJ,CAAUT,GAAG,CAACwC,yBAAJ,CAA8BJ,QAA9B,EAAwCjB,IAAxC,CAAV,CAAN;AACH;;AAEDG,MAAAA,IAAI,GAAGM,MAAP;AACAS,MAAAA,QAAQ,GAAG/B,OAAX;AACH,KAdD,MAcO;AACH,YAAMmC,SAAS,GAAGL,QAAlB;AACA,UAAIM,UAAU,GAAGD,SAAS,CAACE,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAA7C,CAFG,CAIH;;AACArB,MAAAA,IAAI,GAAGM,MAAM,IAAI,IAAV,GAAkBc,UAAU,GAAG3C,IAAI,CAAC6B,MAAD,EAASa,SAAT,CAAP,GAA6Bb,MAAM,CAACa,SAAD,CAA/D,GAA8EG,SAArF;AAEAP,MAAAA,QAAQ,GAAG1C,eAAe,CAACW,OAAD,EAAUsB,MAAV,EAAkBa,SAAlB,EAA6BnB,IAA7B,CAA1B;;AAEA,UAAIgB,OAAO,IAAI,IAAX,IAAmBzC,aAAa,CAACyC,OAAD,CAApC,EAA+C;AAC3CnC,QAAAA,EAAE,GAAGP,GAAG,CAACiD,KAAT;AACH,OAFD,MAEO;AACH1C,QAAAA,EAAE,GAAGP,GAAG,CAACkD,KAAT;AACH;AACJ;;AAED,QAAI,CAACzB,IAAI,CAACC,IAAD,EAAOnB,EAAP,EAAWmC,OAAX,EAAoBH,QAApB,EAA8BE,QAA9B,CAAT,EAAkD;AAC9C,UAAIJ,WAAJ,EAAiB;AACb,eAAO,KAAP;AACH;;AAED,YAAMjB,MAAM,GAAGd,uBAAuB,CAACC,EAAD,EAAKmB,IAAL,EAAWgB,OAAX,EAAoBD,QAApB,CAAtC;;AACA,UAAIP,UAAU,IAAIZ,UAAlB,EAA8B;AAC1B,cAAM,IAAIzB,eAAJ,CAAoBuB,MAApB,EAA4BM,IAA5B,EAAkCe,QAAQ,CAAClB,IAA3C,CAAN;AACH;;AAEDe,MAAAA,MAAM,CAACa,IAAP,CAAY3B,UAAU,GAAGJ,MAAH,GAAY,IAAIvB,eAAJ,CAAoBuB,MAApB,EAA4BM,IAA5B,EAAkCe,QAAQ,CAAClB,IAA3C,CAAlC;;AACA,UAAIW,UAAJ,EAAgB;AACZ;AACH;AACJ;AACJ;;AAED,MAAII,MAAM,CAACH,MAAP,GAAgB,CAApB,EAAuB;AACnB,QAAIE,WAAJ,EAAiB;AACb,aAAO,KAAP;AACH;;AAED,QAAIf,UAAJ,EAAgB;AACZ,YAAM,IAAIzB,eAAJ,CAAoByC,MAApB,EAA4BN,MAA5B,EAAoCT,IAApC,CAAN;AACH;;AAED,WAAOe,MAAM,CAACH,MAAP,KAAkB,CAAlB,IAAuBX,UAAvB,GAAoCc,MAAM,CAAC,CAAD,CAA1C,GAAgDA,MAAvD;AACH;;AAED,SAAO,IAAP;AACH;;AAED,eAAeP,QAAf","sourcesContent":["// JSON Expression Syntax (JES) for validation\nimport ValidationError from './ValidationError';\nimport config, { getChildContext } from './config';\nimport ops from './validateOperators';\nimport { isPlainObject, get as _get } from '@genx/july';\n\nconst MSG = config.messages;\n\nfunction getUnmatchedExplanation(op, leftValue, rightValue, context) {\n    if (context.$$ERROR) {\n        return context.$$ERROR;\n    }\n\n    if (!MSG.validationErrors) {\n        throw new Error('Please import locale first before using validators.');\n    }\n    const getter = MSG.validationErrors[op];\n    return getter(context.name, leftValue, rightValue, context);\n}\n\nexport function invalidType(value, type, options, context) {\n    const reason = MSG.validationErrors[ops.TYPE](context.name, value, type, context);\n\n    if (options.throwError) {\n        throw new ValidationError(reason, value, context.path);\n    }\n\n    return options.plainError ? reason : new ValidationError(reason, value, context.path);\n}\n\nexport function test(left, op, right, options, context) {\n    const handler = config.getValidator(op);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TEST_HANLDER(op));\n    }\n\n    return handler(left, right, options, context);\n}\n\n/**\n * Validate the given object with JSON Expression Syntax (JES)\n * @param {*} actual - The object to match\n * @param {*} expectedJES - Expected state in JSON Expression Syntax\n * @param {*} options - Validation options\n * @param {*} context - Validation context\n * @returns {array} - [ {boolean} matched, {string} unmatchedReason ]\n */\nfunction validate(actual, expectedJES, options = { throwError: true, abortEarly: true }, context = {}) {\n    const type = typeof expectedJES;\n\n    if (type === 'string') {\n        if (expectedJES.length === 0 || expectedJES[0] !== '$') {\n            throw new Error(MSG.SYNTAX_INVALID_EXPR(expectedJES));\n        }\n\n        return validate(actual, { [expectedJES]: null }, options, context);\n    }\n\n    const { throwError, abortEarly, asPredicate, plainError } = options;\n\n    if (expectedJES == null) {\n        return true;\n    }\n\n    let { path } = context;\n    const errors = [];\n    const _options = !abortEarly && throwError ? { ...options, throwError: false } : options;\n\n    for (let operator in expectedJES) {\n        let op, left, _context;\n\n        const opValue = expectedJES[operator];\n\n        if (\n            // $match\n            (operator.length > 1 && operator[0] === '$') ||\n            // |>$all\n            (operator.length > 3 && operator[0] === '|' && operator[2] === '$')\n        ) {\n            //validator\n            op = config.getValidatorTag(operator);\n            if (!op) {\n                throw new Error(MSG.UNSUPPORTED_VALIDATION_OP(operator, path));\n            }\n\n            left = actual;\n            _context = context;\n        } else {\n            const fieldName = operator;\n            let complexKey = fieldName.indexOf('.') !== -1;\n\n            //pick a field and then apply manipulation\n            left = actual != null ? (complexKey ? _get(actual, fieldName) : actual[fieldName]) : undefined;\n\n            _context = getChildContext(context, actual, fieldName, left);\n\n            if (opValue != null && isPlainObject(opValue)) {\n                op = ops.MATCH;\n            } else {\n                op = ops.EQUAL;\n            }\n        }\n\n        if (!test(left, op, opValue, _options, _context)) {\n            if (asPredicate) {\n                return false;\n            }\n\n            const reason = getUnmatchedExplanation(op, left, opValue, _context);\n            if (abortEarly && throwError) {\n                throw new ValidationError(reason, left, _context.path);\n            }\n\n            errors.push(plainError ? reason : new ValidationError(reason, left, _context.path));\n            if (abortEarly) {\n                break;\n            }\n        }\n    }\n\n    if (errors.length > 0) {\n        if (asPredicate) {\n            return false;\n        }\n\n        if (throwError) {\n            throw new ValidationError(errors, actual, path);\n        }\n\n        return errors.length === 1 && plainError ? errors[0] : errors;\n    }\n\n    return true;\n}\n\nexport default validate;\n"]}